@startuml full design

' ------------------------------------------------------------------------------
' ------------------------------------------------------------------------------

package main_header {
    struct engine_entity_template as "entity_template" {
        + void *data
        + size_t data_size
        ..
        + {field} void (*on_init)(void *data, tarasque_engine *handle)
        + {field} void (*on_deinit)(void *data, tarasque_engine *handle)
        + {field} void (*on_frame)(void *data, float elapsed_ms, tarasque_engine *handle)
        __
    }
}

' ------------------------------------------------------------------------------
' ------------------------------------------------------------------------------

package identifier {

    struct identifier {
        == typedef of ==
        {field} range(unsigned char)
    }

    struct path {
        == typedef of ==
        {field} range(identifier)
    }
    path --* "*" identifier

}

' ------------------------------------------------------------------------------
' ------------------------------------------------------------------------------

package entity {
    struct engine_entity_template_copy as "entity_template_copy"  {
        == typedef of ==
        entity_template
        __
        + entity_template_copy entity_template_copy_create(entity_template template, allocator alloc)
        + void entity_template_copy_destroy(entity_template_copy *template, allocator alloc)
    }
    note bottom of engine_entity_template_copy : used to signal memory allocation
    engine_entity_template_copy <--> engine_entity_template

    ' ------------------------------------------------------------------------------

    struct engine_entity as "entity" << (*, SteelBlue) >> {
        - identifier *id
        - entity *parent
        - {field} range(entity *) *children
        ..
        - entity_template_copy template
        __
        + entity *entity_create(identifier *id, entity_template_copy template, allocator alloc)
        + void entity_destroy(entity **target, allocator alloc)
        ..
        + void entity_add_child(entity *target, entity *new_child, allocator alloc)
        + void entity_deparent(entity *target)
        + entity *entity_get_child(entity *target, path *id_path)
        + range(entity *) *entity_get_children(entity *target, allocator alloc)
    }
    engine_entity::template --* "1" engine_entity_template_copy
    engine_entity::id --* "1" identifier
}

' ------------------------------------------------------------------------------
' ------------------------------------------------------------------------------

package command {

    struct engine_command_add_entity as "command_add_entity" {
        + path *id_path
        + identifier *id
        + entity_template_copy template
    }
    engine_command_add_entity::template --* "1" engine_entity_template_copy
    engine_command_add_entity::id_path --* "1" path
    engine_command_add_entity::id --* "1" identifier

    ' ------------------------------------------------------------------------------

    struct engine_command_remove_entity as "command_remove_entity" {
        + path *id_path
    }
    engine_command_remove_entity::id_path --* "1" path

    ' ------------------------------------------------------------------------------

    struct engine_command_subscribe_to_event as "command_subscribe_to_event" {
        + identifier *target_event_name
        + entity *subscribed
        + {field} void (*callback)(void *entity_data, void *event_data)
    }
    engine_command_subscribe_to_event::target_event_name --* "1" identifier
    engine_command_subscribe_to_event::subscribed --o "1" engine_entity

    ' ------------------------------------------------------------------------------

    enum engine_command_flavor as "command_flavor" {
        INVALID
        ADD_ENTITY
        REMOVE_ENTITY
        SUBSCRIBE_TO_EVENT
    }
    engine_command_flavor::ADD_ENTITY .. engine_command_add_entity
    engine_command_flavor::REMOVE_ENTITY .. engine_command_remove_entity
    engine_command_flavor::SUBSCRIBE_TO_EVENT .. engine_command_subscribe_to_event

    ' ------------------------------------------------------------------------------

    struct engine_command as "command" {
        + command_flavor flavor
        + entity *source
        + union { command_add_entity, command_remove_entity, engine_command_subscribe_to_event } cmd

        + command command_create_add_entity(entity *source, char *id_path, char *id, engine_entity_template template, allocator alloc)
        + command command_create_remove_entity(entity *source, char *id_path, allocator alloc)
        + command command_create_subscribe_to_event(entity *source, char *event_name, void (*callback)(void *entity_data, void *event_data), allocator alloc)
        + void command_destroy(command *cmd, allocator alloc)
    }
    engine_command::flavor -- engine_command_flavor
    engine_command::source --o "1" engine_entity
    engine_command::cmd --* engine_command_add_entity
    engine_command::cmd --* engine_command_remove_entity
    engine_command::cmd --* engine_command_subscribe_to_event

    ' ------------------------------------------------------------------------------

    struct engine_command_queue as "command_queue" << (*, SteelBlue) >> {
        - {field} range(command) *queue
        __
        + command_queue *command_queue_create(allocator alloc)
        + void command_queue_destroy(command_queue **queue, allocator alloc)
        ..
        + void command_queue_append(command_queue *queue, command cmd, allocator alloc)
        + command command_queue_pop_front(command_queue *queue)
        + size_t command_queue_length(command_queue *queue)
        ..
        + void command_queue_remove_commands_of(command_queue *queue, entity *target, allocator alloc)
    }
    engine_command_queue::queue --* "0..*" engine_command
}

' ------------------------------------------------------------------------------
' ------------------------------------------------------------------------------

package event {
    struct engine_subscription as "subscription" {
        + entity *subscribed
        ..
        + identifier *target_event_name
        + {field} void (*callback)(void *entity_data, void *event_data)
        __
    }
    engine_subscription::target_event_name --* "1" identifier
    engine_subscription::subscribed --o "1" engine_entity

    ' ------------------------------------------------------------------------------

    struct engine_event_broker as "event_broker" << (*, SteelBlue) >> {
        - {field} range(subscription) *subs
        __
        + event_broker *event_broker_create(allocator alloc)
        + void event_broker_destroy(event_broker **broker, allocator alloc)
        ..
        + void event_broker_subscribe(event_broker *broker, entity *subscribed, identifier *target_event_name, void (*callback)(void *entity_data, void *event_data), allocator alloc)
        + void event_broker_unsubscribe(event_broker *broker, entity *target, identifier *target_event_name, void (*callback)(void *entity_data, void *event_data), allocator alloc)
        + void event_broker_publish(event_broker *broker, event ev)
    }
    engine_event_broker::subs --* "0..*" engine_subscription

    ' ------------------------------------------------------------------------------

    struct engine_event as "event" {
        + identifier *name
        ..
        + size_t data_size
        + void *data
        __
        + event event_create(char *name, size_t data_size, void *data, allocator alloc)
        + event event_destroy(event *ev, allocator alloc)
    }
    engine_event::name --* "1" identifier

    ' ------------------------------------------------------------------------------

    struct engine_event_copy as "event_copy"  {
        == typedef of ==
        event
        __
        + event_copy event_copy_create(event template, allocator alloc)
        + void event_copy_destroy(event_copy *template, allocator alloc)
    }
    note bottom of engine_event_copy : used to signal memory allocation
    engine_event_copy <--> engine_event

    ' ------------------------------------------------------------------------------

    struct engine_event_stacked as "event_stacked" {
        + entity *source
        + event_copy ev
        __
    }
    engine_event_stacked::source --o "0..1" engine_entity
    engine_event_stacked::ev --* "1" engine_event_copy

    ' ------------------------------------------------------------------------------

    struct engine_event_stack as "event_stack" << (*, SteelBlue) >> {
        - {field} range(event_stacked) *stack
        __
        + event_stack *event_stack_create(allocator alloc)
        + void event_stack_destroy(event_stack **stack, allocator alloc)
        ..
        + void event_stack_push(event_stack *stack, entity *source, event ev, allocator alloc)
        + engine_event_copy event_stack_pop(event_stack *stack)
    }
    engine_event_stack::stack --* "0..*" engine_event_stacked
}

' ------------------------------------------------------------------------------
' ------------------------------------------------------------------------------

package main_header {
    struct tarasque_engine << (*, SteelBlue) >> {
        - command_queue *commands
        - event_stack *events
        - event_broker *pub_sub
        - entity *root_entity
        - bool should_quit
        - allocator alloc
        __
        + tarasque_engine *tarasque_engine_create(void)
        + void tarasque_engine_destroy(tarasque_engine **handle)
        ..
        + void tarasque_engine_run(tarasque_engine *handle, int fps)
        + void tarasque_engine_quit(tarasque_engine *handle)
        ..
        + void tarasque_engine_add_entity(tarasque_engine *handle, char *str_path, char *str_id, entity_template template)
        + void tarasque_engine_remove_entity(tarasque_engine *handle, char *str_path)
        + void tarasque_engine_stack_event(tarasque_engine *handle, char *str_id, size_t data_size, void *data, bool is_detached)
        + void tarasque_engine_subscribe_to_event(tarasque_engine *handle, char *str_id, void (*callback)(void *entity_data, void *event_data))
    }
    tarasque_engine::root_entity --* "1" engine_entity
    tarasque_engine::commands --* "1" engine_command_queue
    tarasque_engine::pub_sub --* "1" engine_event_broker
    tarasque_engine::events --* "1" engine_event_stack
}

@enduml
